## Leetcode 85 Maximal Rectangle


> 这个问题如果我们用dp(n,m)来表征他的状态的话，我们需要知道的是当前最大正方形的长和宽，才能知道 下一个状态的长和宽是多少，但是如果这个n,m是行和列的话，我们就无法得知当前最大正方形的长宽，如果用四维dp的话，感觉空间复杂度就会非常高。也就是**dp(n,m,h,w)**,这里怎么优化这个状态变量呢？或者说怎么重新选取呢，如果没有n,m我们就无法进行连续的迭代，就是dp的更新。唯一的优化就是pair<h,maxsofar>dp(n,m)，我们可以通过dp的值获取maxsofar/h = w,注意我这里表征状态都是二维的。

## 答案

>网上的solution都是基于直方图来做，当然你知道了别人的算法再实现剩下的就是debug的事情了，但是怎么想出来的呢，直方图在这里改变了什么呢？改变的是我们每次状态变化的维度，我们一开始状态变化只变化了1个，这里一次变化就是变化了m,一直维护的是m的空间的滚动数组。剩下的部分就是比较trick的部分了，用直方图来计算最大正方形，怎么想出来的呢？ 感觉这个跟计算机图形学有关，不是一步就能想出来的，肯定是规律发现的。


## Leetcode 115 Distinct Subsequences

> 首先能想到的是最简单的方法，如rabbbit,rabbit,分别用S表示总串，用t表示字串，用以下方式查找,t[0]~t[n-1]的每个，例如说t[0]r,如果找到r,例如rra,我们就有两个r，如果后面都合适的话就等于有两个方法，但是如果rar如果第二个r后面再也没有a了，那第二个r就是invalid的，例如rarbbbit,找到第二个r，然后递归bbbit和abbit继续，找得到就继续。那么如果原串是rarabbbit，那么递归的话就变成abbbit。没有优化之前是这样的，先记录模式串t[0]~t[n-1]的t[i]在总串的全部位置，再分别递归看看合不合法。感觉数据量下的话应该可以，如果数据量大的话，估计会stack overflow.

>答案：果然，TLE,实现上还出现了一些错误，第一就是这个递归是返回int，这实际中不需要还有可能出现错误，第二个就是逻辑完备TODO要做好。